---
sidebar: sidebar 
permalink: br-use-protect-kubernetes-applications.html 
keywords: backing up, restoring, back up, backup, restore, cloud volumes ontap, aws, azure, s3, blob, google cloud, storagegrid, back up volumes, cloud backup, restore volumes, cost, on-premises ontap, onprem, applications, virtual machines, backup and recovery, snapcenter 
summary: NetApp Backup and Recovery を使用すると、ワークロード ホスト情報、データベース情報、インスタンス情報を管理できます。インベントリの保護設定を表示、編集、削除できます。 
---
= Kubernetes アプリケーションの追加と保護
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ./media/


[role="lead"]
NetApp Backup and Recovery を使用すると、kubeconfig ファイルを生成してアップロードしなくても、Kubernetes クラスターを簡単に検出できます。  NetApp Consoleのユーザー インターフェイスからコピーした簡単なコマンドを使用して、Kubernetes クラスターを接続し、必要なソフトウェアをインストールできます。

.必要なNetApp Consoleロール
組織管理者またはSnapCenter管理者。link:reference-roles.html["NetApp Backup and Recoveryのアクセス ロールについて学習します"] 。 https://docs.netapp.com/us-en/console-setup-admin/reference-iam-predefined-roles.html["すべてのサービスに対するNetApp Consoleのアクセスロールについて学習します"^] 。



== 新しいKubernetesアプリケーションを追加して保護する

Kubernetes アプリケーションを保護するための最初のステップは、NetApp Backup and Recovery内にアプリケーションを作成することです。アプリケーションを作成すると、Kubernetes クラスター上で実行中のアプリケーションがコンソールに認識されます。

.開始する前に
Kubernetesアプリケーションを追加して保護する前に、link:br-start-discover.html["Kubernetesワークロードを発見する"] 。

[role="tabbed-block"]
====
.Web UI を使用してアプリケーションを追加する
--
.手順
. NetApp Backup and Recoveryで、*Inventory* を選択します。
. Kubernetes インスタンスを選択し、[表示] を選択して、そのインスタンスに関連付けられているリソースを表示します。
. *アプリケーション*タブを選択します。
. *アプリケーションの作成*を選択します。
. アプリケーションの名前を入力します。
. 必要に応じて、次のいずれかのフィールドを選択して、保護するリソースを検索します。
+
** 関連クラスター
** 関連する名前空間
** リソースの種類
** ラベルセレクター


. 必要に応じて、「*クラスタースコープリソース*」を選択して、クラスターレベルでスコープ指定されたリソースを選択します。これらのリソースを含めると、アプリケーションの作成時にアプリケーションに追加されます。
. 必要に応じて、「*検索*」を選択し、検索条件に基づいてリソースを検索します。
+

NOTE: コンソールには検索パラメータや結果は保存されません。パラメータは、選択した Kubernetes クラスターでアプリケーションに含めることができるリソースを検索するために使用されます。

. コンソールには、検索条件に一致するリソースのリストが表示されます。
. 保護するリソースがリストに含まれている場合は、[次へ] を選択します。
. 必要に応じて、「*ポリシー*」領域で、アプリケーションを保護するための既存の保護ポリシーを選択するか、新しいポリシーを作成します。ポリシーを選択しない場合、アプリケーションは保護ポリシーなしで作成されます。あなたはできるlink:br-use-policies-create.html#create-a-policy["保護ポリシーを追加する"]後で。
. *プレスクリプトとポストスクリプト*領域で、バックアップ操作の前または後に実行するプレスクリプトまたはポストスクリプトの実行フックを有効にして構成します。プレスクリプトまたはポストスクリプトを有効にするには、少なくとも1つ作成しておく必要があります。link:br-use-manage-execution-hook-templates.html["実行フックテンプレート"] 。
. *作成*を選択します。


.結果
アプリケーションが作成され、Kubernetes インベントリの *アプリケーション* タブのアプリケーション リストに表示されます。  NetApp Consoleは設定に基づいてアプリケーションの保護を有効にし、バックアップとリカバリの *監視* 領域で進行状況を監視できます。

--
.CRを使用してアプリケーションを追加する
--
.手順
. デスティネーション アプリケーションの CR ファイルを作成します：
+
.. カスタムリソース（CR）ファイルを作成し、名前を付けます（例： `my-app-name.yaml`）。
.. 次の属性を設定します：
+
*** *metadata.name*：（_必須_）アプリケーションのカスタム リソースの名前。保護操作に必要な他の CR ファイルはこの値を参照するため、選択した名前を書き留めておいてください。
*** *spec.includedNamespaces*：（_必須_）ネームスペースとラベルセレクタを使用して、アプリケーションが使用するネームスペースとリソースを指定します。アプリケーションネームスペースはこのリストに含まれている必要があります。ラベルセレクタはオプションであり、指定された各ネームスペース内のリソースをフィルタリングするために使用できます。
*** *spec.includedClusterScopedResources*：（_オプション_）この属性を使用して、アプリケーション定義に含めるクラスタスコープのリソースを指定します。この属性を使用すると、グループ、バージョン、種類、ラベルに基づいてこれらのリソースを選択できます。
+
**** *groupVersionKind*：（_必須_）クラスタースコープのリソースの API グループ、バージョン、および種類を指定します。
**** *labelSelector*：（_オプション_）ラベルに基づいてクラスタースコープのリソースをフィルタリングします。




.. 必要に応じて、次のアノテーションを設定します：
+
*** *metadata.annotations.protect.trident.netapp.io/skip-vm-freeze*：（_オプション_）このアノテーションは、KubeVirt環境など、スナップショットの前にファイルシステムのフリーズが発生する仮想マシンから定義されたアプリケーションにのみ適用されます。スナップショット中にこのアプリケーションがファイルシステムに書き込むことができるかどうかを指定します。trueに設定すると、アプリケーションはグローバル設定を無視し、スナップショット中にファイルシステムに書き込むことができます。falseに設定すると、アプリケーションはグローバル設定を無視し、スナップショット中にファイルシステムがフリーズされます。指定されていても、アプリケーション定義にアプリケーションの仮想マシンがない場合、アノテーションは無視されます。指定されていない場合、アプリケーションはlink:trident-protect-requirements.html#protecting-data-with-kubevirt-vms["グローバル ファイルシステム フリーズ設定"]に従います。
*** *protect.trident.netapp.io/protection-command*：（_オプション_）この注釈を使用して、NetApp Backup and Recoveryにアプリケーションの保護または保護の停止を指示します。指定可能な値は `protect`または `unprotect`です。
*** *protect.trident.netapp.io/protection-policy-name*：（_オプション_）このアノテーションを使用して、このアプリケーションを保護するために使用するNetApp Backup and Recovery保護ポリシーの名前を指定します。この保護ポリシーは、NetApp Backup and Recoveryにすでに存在している必要があります。
+
[NOTE]
====
アプリケーションがすでに作成された後にこのアノテーションを適用する必要がある場合は、次のコマンドを使用できます：

[source, console]
----
kubectl annotate application -n <application CR namespace> <application CR name> protect.trident.netapp.io/skip-vm-freeze="true"
----
====
+
YAMLの例：

+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: Application
metadata:
  annotations:
    protect.trident.netapp.io/skip-vm-freeze: "false"
    protect.trident.netapp.io/protection-command: "protect"
    protect.trident.netapp.io/protection-policy-name: "policy-name"
  name: my-app-name
  namespace: my-app-namespace
spec:
  includedNamespaces:
    - namespace: namespace-1
      labelSelector:
        matchLabels:
          app: example-app
    - namespace: namespace-2
      labelSelector:
        matchLabels:
          app: another-example-app
  includedClusterScopedResources:
    - groupVersionKind:
        group: rbac.authorization.k8s.io
        kind: ClusterRole
        version: v1
      labelSelector:
        matchLabels:
          mylabel: test
----




. （_オプション_）特定のラベルでマークされたリソースを含めるか除外するかを指定するフィルタリングを追加します：
+
** *resourceFilter.resourceSelectionCriteria*：（フィルタリングに必須） `Include`または `Exclude`を使用して、resourceMatchersで定義されたリソースを含めるか除外します。含めるまたは除外するリソースを定義するには、以下のresourceMatchersパラメータを追加します：
+
*** *resourceFilter.resourceMatchers*：resourceMatcherオブジェクトの配列。この配列に複数の要素を定義すると、それらはOR演算として一致し、各要素内のフィールド（グループ、種類、バージョン）はAND演算として一致します。
+
**** *resourceMatchers[].group*：（_オプション_）フィルタリングするリソースのグループ。
**** *resourceMatchers[].kind*：（_オプション_）フィルタリングするリソースの種類。
**** *resourceMatchers[].version*：（_オプション_）フィルタリングするリソースのバージョン。
**** *resourceMatchers[].names*：（_オプション_）フィルタリングするリソースの Kubernetes metadata.name フィールド内の名前。
**** *resourceMatchers[].namespaces*：（_オプション_）フィルタリングするリソースの Kubernetes metadata.name フィールド内の名前空間。
**** *resourceMatchers[].labelSelectors*：（_オプション_） https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Kubernetesドキュメント"^]で定義されているリソースのKubernetesメタデータ.nameフィールドのラベルセレクタ文字列。例： `"trident.netapp.io/os=linux"`。
+

NOTE:  `resourceFilter`と `labelSelector`の両方が使用される場合、 `resourceFilter`が最初に実行され、次に `labelSelector`が結果のリソースに適用されます。

+
例：

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "Include"
    resourceMatchers:
      - group: my-resource-group-1
        kind: my-resource-kind-1
        version: my-resource-version-1
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
      - group: my-resource-group-2
        kind: my-resource-kind-2
        version: my-resource-version-2
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
----






. 環境に合わせてアプリケーション CR を作成したら、CR を適用します。例：
+
[source, console]
----
kubectl apply -f my-app-name.yaml
----


--
====